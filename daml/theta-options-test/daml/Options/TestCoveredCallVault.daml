module Options.TestCoveredCallVault where

import Daml.Script
import Options.CoveredCallVault
import DA.Time
import DA.Date
import DA.Assert

testCoveredCallVault : Script ()
testCoveredCallVault = do
  provider <- allocateParty "provider"
  dso <- allocateParty "dso"
  let vaultId = "vault-001"
  let name = "Test Vault"
  let asset = "BTC"
  let underlying = "CC"
  let expiresAt = time (date 2025 Jan 1) 0 0 0
  let params = VaultParams

  vault <- submit provider do
    createCmd CoveredCallVault with
      provider = provider
      dso = dso
      vaultId = vaultId
      name = name
      strike = 0.0
      size = 0.0
      asset = asset
      underlying = underlying
      lpPrice = 1.0
      premiumAmount = 0.0
      epoch = 0
      expiresAt = expiresAt
      epochMm = None
      status = Closed
      params = params

  -- Verify the vault was created with correct initial values
  Some vaultData <- queryContractId provider vault
  vaultData.strike === 0.0
  vaultData.size === 0.0
  vaultData.premiumAmount === 0.0
  vaultData.epoch === 0
  vaultData.status === Closed
  vaultData.provider === provider
  vaultData.dso === dso

  vault <- submit provider do
    exerciseCmd vault CoveredCallVault_UpdateName with
      newName = "Updated Test Vault"

  submit provider do
    exerciseCmd vault CoveredCallVault_Archive

  pure ()

testVaultWorkflow : Script ()
testVaultWorkflow = do
  provider <- allocateParty "provider"
  dso <- allocateParty "dso"
  mm <- allocateParty "mm"
  let vaultId = "vault-002"
  let name = "Setup Epoch Vault"
  let asset = "ETH"
  let underlying = "CC"
  let expiresAt = time (date 2025 Jan 1) 0 0 0
  let params = VaultParams

  -- Step 1: Create the vault with initial state
  vault <- submit provider do
    createCmd CoveredCallVault with
      provider = provider
      dso = dso
      vaultId = vaultId
      name = name
      strike = 0.0
      size = 1000.0
      asset = asset
      underlying = underlying
      lpPrice = 1.0
      premiumAmount = 0.0
      epoch = 0
      expiresAt = expiresAt
      epochMm = None
      status = Closed
      params = params

  -- Verify initial vault state
  Some initialVaultData <- queryContractId provider vault
  initialVaultData.strike === 0.0
  initialVaultData.size === 1000.0
  initialVaultData.premiumAmount === 0.0
  initialVaultData.epoch === 0
  initialVaultData.status === Closed
  initialVaultData.epochMm === None
  initialVaultData.provider === provider
  initialVaultData.dso === dso

  -- Step 2: Lock the vault (required before setting up epoch)
  vault <- submit provider do
    exerciseCmd vault CoveredCallVault_LockVault

  -- Verify vault is now locked
  Some lockedVaultData <- queryContractId provider vault
  lockedVaultData.status === Locked
  lockedVaultData.strike === 0.0
  lockedVaultData.size === 1000.0

  -- Step 3: Setup epoch - this creates an EpochInitializationRequest and updates vault status
  let newExpiry = time (date 2025 Jan 2) 0 0 0  -- New epoch expires 1 day into future
  (updatedVault, request) <- submit provider do
    exerciseCmd vault CoveredCallVault_SetupEpoch with
      newStrike = 5000.0
      newPremiumAmount = 100.0
      newMm = mm
      newExpiresAt = newExpiry

  -- Verify the vault was updated correctly
  Some setupVaultData <- queryContractId provider updatedVault
  setupVaultData.status === Ready
  setupVaultData.epochMm === Some mm
  setupVaultData.expiresAt === expiresAt  -- Expiry is not changed during setup, only when epoch is accepted

  -- Verify the EpochInitializationRequest was created correctly
  Some requestData <- queryContractId provider request
  requestData.provider === provider
  requestData.mm === mm
  requestData.dso === dso
  requestData.vaultId === updatedVault
  requestData.newStrike === 5000.0
  requestData.newPremiumAmount === 100.0
  requestData.expiresAt === newExpiry

  -- Step 4: Both MM and provider accept the epoch initialization request (both are controllers)
  finalVault <- submitMulti [mm, provider] [] do
    exerciseCmd request EpochInitializationRequest_Accept

  -- Verify final vault state after epoch initialization
  Some finalVaultData <- queryContractId provider finalVault
  finalVaultData.strike === 5000.0
  finalVaultData.premiumAmount === 100.0
  finalVaultData.epoch === 1
  finalVaultData.status === Live
  finalVaultData.epochMm === None  -- MM is cleared after initialization
  finalVaultData.size === 1100.0   -- Size should be 1000.0 + 100.0 premium amount
  finalVaultData.lpPrice === 1.1   -- LP price should be updated: 1.0 * 1100.0 / 1000.0 = 1.1
  finalVaultData.expiresAt === newExpiry  -- Verify new expiry date is preserved

  -- Verify the request contract was archived
  None <- queryContractId provider request

  -- Vault remains active and ready for further operations
  pure ()
