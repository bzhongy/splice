-- Copyright (c) 2025, Thetanuts Asset Corp. All rights reserved.
-- SPDX-License-Identifier: 0BSD

-- | Bilateral agreement contracts that represent agreements between two parties.
-- Allows any party to create a BilateralRequest to another party for establishing
-- bilateral agreements with custom terms and expiration dates.
--
-- IMPORTANT: Only one active bilateral agreement should exist between any user and mm pair.
-- Before creating a new agreement, any existing agreement between the same parties
-- should be cancelled or expired.
module Options.Bilateral where

import Splice.Util (HasCheckedFetch(..), fetchAndArchive, require)
-- import DA.Time

-- | Parameters determining the bilateral agreement behavior.
data BilateralParams = BilateralParams with
    description : Text -- ^ Free text description of the agreement terms and purpose.
  deriving (Eq, Show)

-- | Group identifier for bilateral agreements
data BilateralGroup = BilateralGroup with
    user : Party
    mm : Party
    dso : Party
  deriving (Show, Eq)

-- | A bilateral agreement between two parties
-- Note: Only one active agreement should exist between any user and mm pair
template Bilateral with
    user : Party -- ^ Party requesting/initiating the bilateral agreement.
    mm : Party -- ^ Market maker or counterparty that user is onboarding with.
    dso : Party -- ^ DSO party (required for system integration).
    expiresAt : Time -- ^ Date when the bilateral agreement expires.
    params : BilateralParams -- ^ Parameters including description and metadata.
  where
    signatory user, mm
    -- No additional observers needed - only signatories (user, mm) can see this agreement
    
    -- | Expire the bilateral agreement after expiration date
    choice Bilateral_Expire : ()
      with
        actor : Party -- ^ Party that initiated the expiration.
      controller actor
      do
        now <- getTime
        require "Actor is a signatory" (actor `elem` signatory this)
        require "Agreement has expired" (now > expiresAt)


    -- | Extend the bilateral agreement to a new expiration date
    nonconsuming choice Bilateral_Extend : ContractId BilateralExtensionRequest
      with
        newExpirationDate : Time
        extensionReason : Text
      controller user, mm -- Both parties must agree to extend
      do
        now <- getTime
        require "New expiration must be in the future" (newExpirationDate > now)
        require "New expiration must be later than current" (newExpirationDate > expiresAt)
        
        create BilateralExtensionRequest with
          user, mm, dso
          originalAgreementId = self
          newExpirationDate
          extensionReason

    -- | Initiate a cancellation (scrap) request for the active bilateral agreement.
    -- One party proposes to cancel; the counterparty must accept for the agreement to be archived.
    nonconsuming choice Bilateral_RequestCancel : ContractId BilateralCancelRequest
      with
        actor : Party
        reason : Text
      controller actor
      do
        require "Actor is a signatory" (actor `elem` signatory this)
        let receiver = if actor == user then mm else user
        create BilateralCancelRequest with
          user, mm, dso
          originalAgreementId = self
          canceler = actor
          receiver
          reason

-- | A request to extend an existing bilateral agreement
template BilateralExtensionRequest with
    user : Party
    mm : Party
    dso : Party
    originalAgreementId : ContractId Bilateral
    newExpirationDate : Time
    extensionReason : Text
  where
    signatory user, mm
    -- No additional observers needed - only signatories (user, mm) can see extension requests

    choice BilateralExtensionRequest_Accept : ContractId Bilateral
      controller user, mm -- Both parties must accept
      do
        originalAgreement <- fetchAndArchive BilateralGroup {user, mm, dso} originalAgreementId
        
        create Bilateral with
          user = originalAgreement.user
          mm = originalAgreement.mm
          dso = originalAgreement.dso
          expiresAt = newExpirationDate
          params = originalAgreement.params

    choice BilateralExtensionRequest_Cancel : ()
      with
        actor : Party
      controller actor
      do
        require "Actor is a signatory" (actor `elem` signatory this)

-- | A request to cancel an existing bilateral agreement. Created by one party (canceler),
-- the other party (receiver) must accept for the bilateral to be archived.
template BilateralCancelRequest with
    user : Party
    mm : Party
    dso : Party
    originalAgreementId : ContractId Bilateral
    canceler : Party
    receiver : Party
    reason : Text
  where
    signatory canceler
    observer receiver

    -- Counterparty accepts cancellation; archive the agreement
    choice BilateralCancelRequest_Accept : ()
      controller receiver
      do
        _ <- fetchAndArchive BilateralGroup {user, mm, dso} originalAgreementId
        pure ()

    -- Counterparty rejects cancellation
    choice BilateralCancelRequest_Reject : ()
      controller receiver
      do
        pure ()

    -- Initiator withdraws the cancellation request
    choice BilateralCancelRequest_Withdraw : ()
      controller canceler
      do
        pure ()

-- | A request by a user to establish a bilateral agreement with another party.
-- Note: Before accepting, check that no active agreement exists between these parties.
template BilateralRequest with
    user : Party -- ^ Party requesting the bilateral agreement.
    mm : Party -- ^ Market maker or counterparty being requested.
    dso : Party -- ^ DSO party (required for system integration).
    expiresAt : Time -- ^ Proposed expiration date for the agreement.
    params : BilateralParams -- ^ Proposed parameters including description.

  where
    signatory user
    observer mm  -- Only the target mm can see the request (user already sees it as signatory)

    choice BilateralRequest_Accept : ContractId Bilateral
      controller mm
      do
        create Bilateral with
          user, mm, dso
          expiresAt
          params

    choice BilateralRequest_Reject : ()
      with
        rejectionReason : Text
      controller mm
      do 
        pure ()

    choice BilateralRequest_Cancel : ()
      controller user
      do 
        pure ()

instance HasCheckedFetch Bilateral BilateralGroup where
  contractGroupId Bilateral{..} = BilateralGroup with ..
