module TestVerifierConfig where

import VerifierConfig
import Types.VerifierConfigState
import Interface.ManagedContract
import Interface.TypeAndVersion qualified
import Interface.ConfirmedOwner
import Interface.Observable
import Daml.Script
import DA.Assert ((===))
import DA.Map (Map)
import qualified DA.Map as Map
import DA.Crypto.Text (BytesHex)
import DA.List (head)

testConfigDigest1 : BytesHex
testConfigDigest1 = "0006bd87830d5f336e205cf5c63329a1dab8f5d56812eaeb7c69300e66ab8e22"

testConfigDigest2 : BytesHex
testConfigDigest2 = "1111111111111111111111111111111111111111111111111111111111111111"

testPublicKey1 : BytesHex
testPublicKey1 = "0493fd6c70d37ce9eb08a439c5f6d4dee63ea00e72de91d410340ac57588108f35b8cb924127cffb3ebc5fbc7dfa67947f5400726e39fe01bf41a95696bc178164"

testPublicKey2 : BytesHex
testPublicKey2 = "0497c5bd3b562d252d2a7f50df14cfab01640d605e6cf849662048686cc672e83324b8875800a70b2845119ce2da311fc7c13431c1ca01b67f699840b6cbdb77a9"

-- Create a test VerifierConfig with minimal state
createTestVerifierConfig : Party -> [Party] -> Script (ContractId VerifierConfig)
createTestVerifierConfig owner observers = do
  submit owner $ createCmd VerifierConfig with
    confirmedOwnerView = ConfirmedOwnerView with
      owner = owner
      pendingOwner = None
    observableView = ObservableView with
      observers = observers
    verifierConfigStateView = VerifierConfigStateView with
      verifierStates = Map.empty
    managedContractView = ManagedContractView with
      uuid = show (head observers)
      user = head observers

-- Create a test VerifierConfig with populated state
createTestVerifierConfigWithState : Party -> [Party] -> Map BytesHex VerifierConfigDigest -> Script (ContractId VerifierConfig)
createTestVerifierConfigWithState owner observers states = do
  currentTime <- getTime
  submit owner $ createCmd VerifierConfig with
    confirmedOwnerView = ConfirmedOwnerView with
      owner = owner
      pendingOwner = None
    observableView = ObservableView with
      observers = observers
    verifierConfigStateView = VerifierConfigStateView with
      verifierStates = states
    managedContractView = ManagedContractView with
      uuid = show (head observers)
      user = head observers

-- Helper to create a test VerifierConfigDigest
createTestConfigDigest : Time -> Bool -> Int -> [(BytesHex, Int)] -> VerifierConfigDigest
createTestConfigDigest configTime isActive faultTolerance oraclesList =
  VerifierConfigDigest with
    latestConfigTime = configTime
    isActive = isActive
    f = faultTolerance
    oracles = Map.fromList oraclesList

-- Test: Non-observer cannot query contract
testNonObserverCannotQuery : Script ()
testNonObserverCannotQuery = script do
  owner <- allocateParty "Owner"
  user <- allocateParty "User"
  nonObserver <- allocateParty "NonObserver"
  
  verifierConfigCid <- createTestVerifierConfig owner [user]
  
  -- Verify non-observer cannot query the contract
  None <- queryContractId nonObserver verifierConfigCid
  return ()

-- Test: TypeAndVersion interface returns correct version
testTypeAndVersionInterface : Script ()
testTypeAndVersionInterface = script do
  owner <- allocateParty "Owner"
  user <- allocateParty "User"
  
  -- Create test config
  verifierConfigCid <- createTestVerifierConfig owner [user]
  
  -- Exercise GetTypeAndVersion choice via TypeAndVersion interface
  typeAndVersion <- submit owner $ exerciseCmd 
    (toInterfaceContractId @Interface.TypeAndVersion.TypeAndVersion verifierConfigCid) 
    Interface.TypeAndVersion.GetTypeAndVersion with viewer = owner
  
  -- Verify correct type and version string
  typeAndVersion === "VerifierConfig:1.0.0"

-- Test: ConfirmedOwner interface ownership transfer
testConfirmedOwnerUpdateConfirmedOwner : Script ()
testConfirmedOwnerUpdateConfirmedOwner = script do
  owner <- allocateParty "Owner"
  newOwner <- allocateParty "NewOwner"
  user <- allocateParty "User"
  
  -- Create config with user as observer so newOwner can see it after transfer
  verifierConfigCid <- createTestVerifierConfig owner [user, newOwner]
  
  -- Transfer ownership
  confirmedOwnerCid <- submit owner $ exerciseCmd 
    (toInterfaceContractId @ConfirmedOwner verifierConfigCid)
    TransferOwnership with newOwner = newOwner
  
  -- Verify pending owner is set
  Some config1 <- queryContractId owner (fromInterfaceContractId @VerifierConfig confirmedOwnerCid)
  config1.confirmedOwnerView.pendingOwner === Some newOwner
  
  -- Accept ownership
  confirmedOwnerCid2 <- submit newOwner $ exerciseCmd confirmedOwnerCid AcceptOwnership
  
  -- Verify ownership transferred
  Some config2 <- queryContractId newOwner (fromInterfaceContractId @VerifierConfig confirmedOwnerCid2)
  config2.confirmedOwnerView.owner === newOwner
  config2.confirmedOwnerView.pendingOwner === None
  
  -- Verify state is preserved
  Map.size config2.verifierConfigStateView.verifierStates === 0
  config2.observableView.observers === [user, newOwner]

-- Test: ManagedContract interface returns correct view
testManagedContractInterface : Script ()
testManagedContractInterface = script do
  owner <- allocateParty "Owner"
  user <- allocateParty "User"
  
  -- Create test config
  verifierConfigCid <- createTestVerifierConfig owner [user]
  
  -- Get view via ManagedContract interface by querying the underlying contract
  Some config <- queryContractId owner verifierConfigCid
  let managedView = config.managedContractView
  
  -- Verify uuid matches expected value (show user)
  managedView.uuid === show user
  managedView.user === user

-- Test: Observable interface - AddObserver
testObservableAddObserver : Script ()
testObservableAddObserver = script do
  owner <- allocateParty "Owner"
  user1 <- allocateParty "User1"
  user2 <- allocateParty "User2"
  
  verifierConfigCid <- createTestVerifierConfig owner [user1]
  
  -- Add second observer
  observableCid <- submit owner $ exerciseCmd 
    (toInterfaceContractId @Observable verifierConfigCid)
    AddObserver with newObserver = user2
  
  -- Verify both observers are present (note: AddObserver appends, so user1 is first)
  Some config <- queryContractId owner (fromInterfaceContractId @VerifierConfig observableCid)
  config.observableView.observers === [user1, user2]
  
  -- Verify user2 can now query the contract
  Some _ <- queryContractId user2 (fromInterfaceContractId @VerifierConfig observableCid)
  return ()

-- Test: Observable interface - RemoveObserver
testObservableRemoveObserver : Script ()
testObservableRemoveObserver = script do
  owner <- allocateParty "Owner"
  user1 <- allocateParty "User1"
  user2 <- allocateParty "User2"
  
  verifierConfigCid <- createTestVerifierConfig owner [user1, user2]
  
  -- Remove user2 (user1 is configOwner at index 0 and cannot be removed)
  observableCid <- submit owner $ exerciseCmd 
    (toInterfaceContractId @Observable verifierConfigCid)
    RemoveObserver with observerToRemove = user2
  
  -- Verify only user1 remains
  Some config <- queryContractId owner (fromInterfaceContractId @VerifierConfig observableCid)
  config.observableView.observers === [user1]
  
  -- Verify user2 can no longer query the contract (old contract archived)
  None <- queryContractId user2 verifierConfigCid
  return ()


-- Test: Contract with populated verifierConfigStateView
testPopulatedVerifierConfigState : Script ()
testPopulatedVerifierConfigState = script do
  owner <- allocateParty "Owner"
  user <- allocateParty "User"
  currentTime <- getTime
  
  -- Create config with one state using helper
  let configState1 = createTestConfigDigest currentTime True 1 [(testPublicKey1, 0), (testPublicKey2, 1)]
  let states = Map.fromList [(testConfigDigest1, configState1)]
  
  verifierConfigCid <- createTestVerifierConfigWithState owner [user] states
  
  -- Verify state is correctly stored
  Some config <- queryContractId owner verifierConfigCid
  Map.size config.verifierConfigStateView.verifierStates === 1
  
  -- Verify config state details
  case Map.lookup testConfigDigest1 config.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> do
      state.f === 1
      state.isActive === True
      Map.size state.oracles === 2

-- Test: Contract with multiple configs in state
testMultipleConfigsInState : Script ()
testMultipleConfigsInState = script do
  owner <- allocateParty "Owner"
  user <- allocateParty "User"
  currentTime <- getTime
  
  -- Create two different configs using helper
  let configState1 = createTestConfigDigest currentTime True 1 [(testPublicKey1, 0), (testPublicKey2, 1)]
  let configState2 = createTestConfigDigest currentTime False 0 [(testPublicKey1, 0)]
  let states = Map.fromList [(testConfigDigest1, configState1), (testConfigDigest2, configState2)]
  
  verifierConfigCid <- createTestVerifierConfigWithState owner [user] states
  
  -- Verify both states are correctly stored
  Some config <- queryContractId owner verifierConfigCid
  Map.size config.verifierConfigStateView.verifierStates === 2
  
  -- Verify first config
  case Map.lookup testConfigDigest1 config.verifierConfigStateView.verifierStates of
    None -> abort "Config digest 1 not found"
    Some state -> do
      state.f === 1
      state.isActive === True
      Map.size state.oracles === 2
  
  -- Verify second config
  case Map.lookup testConfigDigest2 config.verifierConfigStateView.verifierStates of
    None -> abort "Config digest 2 not found"
    Some state -> do
      state.f === 0
      state.isActive === False
      Map.size state.oracles === 1

-- Test: State is preserved across interface updates
testStatePreservedAcrossInterfaceUpdates : Script ()
testStatePreservedAcrossInterfaceUpdates = script do
  owner <- allocateParty "Owner"
  user <- allocateParty "User"
  newObserver <- allocateParty "NewObserver"
  currentTime <- getTime
  
  -- Create config with state using helper
  let configState = createTestConfigDigest currentTime True 1 [(testPublicKey1, 0), (testPublicKey2, 1)]
  let states = Map.fromList [(testConfigDigest1, configState)]
  
  verifierConfigCid <- createTestVerifierConfigWithState owner [user] states
  
  -- Add observer through Observable interface
  observableCid <- submit owner $ exerciseCmd 
    (toInterfaceContractId @Observable verifierConfigCid)
    AddObserver with newObserver = newObserver
  
  -- Verify state is preserved after interface update
  Some config <- queryContractId owner (fromInterfaceContractId @VerifierConfig observableCid)
  Map.size config.verifierConfigStateView.verifierStates === 1
  
  case Map.lookup testConfigDigest1 config.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found after interface update"
    Some state -> do
      state.f === 1
      state.isActive === True
      Map.size state.oracles === 2
  
  -- Verify observers updated (AddObserver appends)
  config.observableView.observers === [user, newObserver]

-- Test: Cannot remove observer at index 0 (configOwner)
testCannotRemoveFirstObserver : Script ()
testCannotRemoveFirstObserver = script do
  owner <- allocateParty "Owner"
  user1 <- allocateParty "User1"
  user2 <- allocateParty "User2"
  
  -- Create config with two observers (user1 at index 0, user2 at index 1)
  verifierConfigCid <- createTestVerifierConfig owner [user1, user2]
  
  -- Verify user1 is the first observer (and the managed contract user)
  Some config <- queryContractId owner verifierConfigCid
  head config.observableView.observers === user1
  config.managedContractView.user === user1
  
  -- Try to remove the first observer (user1, who is the managed contract user)
  submitMustFail owner $ exerciseCmd 
    (toInterfaceContractId @Observable verifierConfigCid)
    RemoveObserver with observerToRemove = user1
  
  -- Verify we CAN remove the second observer (user2) successfully
  observableCid <- submit owner $ exerciseCmd 
    (toInterfaceContractId @Observable verifierConfigCid)
    RemoveObserver with observerToRemove = user2
  
  -- Verify only user1 remains
  Some updatedConfig <- queryContractId owner (fromInterfaceContractId @VerifierConfig observableCid)
  updatedConfig.observableView.observers === [user1]
  head updatedConfig.observableView.observers === user1

