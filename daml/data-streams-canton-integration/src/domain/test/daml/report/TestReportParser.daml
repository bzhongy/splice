module TestReportParser where

import Daml.Script
import DA.List
import DA.Assert ((===))
import DA.Crypto.Text (BytesHex, byteCount)
import ReportParser

-- Helper template for testing pure functions that should fail
template ReportTestRunner
  with
    party : Party
  where
    signatory party

    choice TestParseSignedReport : SignedReport
      with payload : BytesHex
      controller party
      do return (parseSignedReport payload)

-- Test: Parsing a complete Data Streams signed report
testParseSignedReport : Script ()
testParseSignedReport = do
  -- Parse the signed report (without "0x" prefix)
  let encodedSignedReport = "0006bd87830d5f336e205cf5c63329a1dab8f5d56812eaeb7c69300e66ab8e220000000000000000000000000000000000000000000000000000000017568517000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000003000101000001010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012000030ab7d02fbba9c6304f98824524407b1f494741174320cfd17a2c22eec1de0000000000000000000000000000000000000000000000000000000066f70fd50000000000000000000000000000000000000000000000000000000066f70fd500000000000000000000000000000000000000000000000000006be8db1c6cec0000000000000000000000000000000000000000000000000059a6ac2ae01b280000000000000000000000000000000000000000000000000000000066f861550000000000000000000000000000000000000000000000000918993b2e27d1c400000000000000000000000000000000000000000000000009181122c12b3f3e00000000000000000000000000000000000000000000000009193714dabc0a3c00000000000000000000000000000000000000000000000000000000000000068c75b34415f03167d2c0dc6b7541c70943bc15eb5b69ce0daa4a6bcd52ce87a5a6919524b2c7e5d09c5008ec768f9dc61dc67dce99d2bd1a2c64ee72e8e4e9514fbe5ff8ac79dff8d19815cc5eb610c5bc6a2493ae45da97250f504680e1895521b788d8593c637d9284d367901b5e1c22121f0c9184bd5c9fa7cabf3fe62acc2490ae1bf9fe3b006d8db1be172f94c82164004e0cff6fa4f1eb969d6c69c0e3b0d034a3c9dae9bc5f308474412b086d51f2be2dc8ff41908b5196eee1a81043000000000000000000000000000000000000000000000000000000000000000636e4960d5792282d0e0df140c75ae225bf24e45b02fd7570a65a80bd2757f56307e48c64d284775de3f4ef733a57db0abc9848f794f25fc4031feca4bc0dda56136cbe31a94b8be0e836cef1b7c788214222a8daeffba13d3b96444eb0591824237f4304930d904c91cffe5063eba240974d0609ea4b7d39c7b239d96e4ae0e46dbb79fd05dcfcf6bd1c6226ecdcf8166f74277abbfc036cd68e49e8c11f879b29100ca344bf0ccf431080cd93f8a39abba5cc326490201a11d2887fe4a3229f"
  let signedReport = parseSignedReport encodedSignedReport

  -- Verify report_context (bytes32[3])
  let context = reportContext signedReport
  length context === 3

  -- Expected report_context values
  let expectedContext0 = "0006bd87830d5f336e205cf5c63329a1dab8f5d56812eaeb7c69300e66ab8e22"
      expectedContext1 = "0000000000000000000000000000000000000000000000000000000017568517"
      expectedContext2 = "0000000000000000000000000000000000000000000000000000000000000000"

  head context === expectedContext0
  (context !! 1) === expectedContext1
  (context !! 2) === expectedContext2

  -- Verify raw_vs (bytes32)
  let expectedRawVs = "0101000001010000000000000000000000000000000000000000000000000000"
  rawVs signedReport === expectedRawVs

  -- Verify rs array (bytes32[])
  let rsArray = rs signedReport
  length rsArray === 6

  -- Expected rs values
  let expectedRs0 = "8c75b34415f03167d2c0dc6b7541c70943bc15eb5b69ce0daa4a6bcd52ce87a5"
      expectedRs1 = "a6919524b2c7e5d09c5008ec768f9dc61dc67dce99d2bd1a2c64ee72e8e4e951"
      expectedRs2 = "4fbe5ff8ac79dff8d19815cc5eb610c5bc6a2493ae45da97250f504680e18955"
      expectedRs3 = "21b788d8593c637d9284d367901b5e1c22121f0c9184bd5c9fa7cabf3fe62acc"
      expectedRs4 = "2490ae1bf9fe3b006d8db1be172f94c82164004e0cff6fa4f1eb969d6c69c0e3"
      expectedRs5 = "b0d034a3c9dae9bc5f308474412b086d51f2be2dc8ff41908b5196eee1a81043"

  -- Check all RS values
  head rsArray === expectedRs0
  (rsArray !! 1) === expectedRs1
  (rsArray !! 2) === expectedRs2
  (rsArray !! 3) === expectedRs3
  (rsArray !! 4) === expectedRs4
  (rsArray !! 5) === expectedRs5

  -- Verify ss array (bytes32[])
  let ssArray = ss signedReport
  length ssArray === 6

  -- Expected ss values
  let expectedSs0 = "36e4960d5792282d0e0df140c75ae225bf24e45b02fd7570a65a80bd2757f563"
      expectedSs1 = "07e48c64d284775de3f4ef733a57db0abc9848f794f25fc4031feca4bc0dda56"
      expectedSs2 = "136cbe31a94b8be0e836cef1b7c788214222a8daeffba13d3b96444eb0591824"
      expectedSs3 = "237f4304930d904c91cffe5063eba240974d0609ea4b7d39c7b239d96e4ae0e4"
      expectedSs4 = "6dbb79fd05dcfcf6bd1c6226ecdcf8166f74277abbfc036cd68e49e8c11f879b"
      expectedSs5 = "29100ca344bf0ccf431080cd93f8a39abba5cc326490201a11d2887fe4a3229f"

  -- Check all SS values
  head ssArray === expectedSs0
  (ssArray !! 1) === expectedSs1
  (ssArray !! 2) === expectedSs2
  (ssArray !! 3) === expectedSs3
  (ssArray !! 4) === expectedSs4
  (ssArray !! 5) === expectedSs5

  -- Verify feed_id (first 32 bytes of report data)
  let reportDataSlice = reportData signedReport
  byteCount reportDataSlice === 288  -- Verify report data length

-- Test: Parsing with insufficient length - should fail
testParseSignedReportInsufficientLength : Script ()
testParseSignedReportInsufficientLength = do
  alice <- allocateParty "Alice"
  let emptyPayload = "0000000000000000000000000000000000000000000000000000000000000000"

  testRunner <- alice `submit` createCmd ReportTestRunner with party = alice

  submitMustFail alice do
    exerciseCmd testRunner TestParseSignedReport with payload = emptyPayload

-- Test parsing with mismatched rs/ss array lengths - should fail
testParseSignedReportMismatchedRsSs : Script ()
testParseSignedReportMismatchedRsSs = do
  alice <- allocateParty "Alice"
  
  -- Create a malformed payload with different array lengths for rs and ss
  -- Static data (7 words = 224 bytes)
  let reportContext = "0006bd87830d5f336e205cf5c63329a1dab8f5d56812eaeb7c69300e66ab8e220000000000000000000000000000000000000000000000000000000017568517000000000000000000000000000000000000000000000000000000000000000"
  let reportDataOffset = "00000000000000000000000000000000000000000000000000000000000000e0"  -- offset to reportData
  let rsOffset = "0000000000000000000000000000000000000000000000000000000000000220"  -- offset to rs
  let ssOffset = "0000000000000000000000000000000000000000000000000000000000000300"  -- offset to ss
  let rawVs = "0101000001010000000000000000000000000000000000000000000000000000"
  
  -- reportData (empty for simplicity)
  let reportDataLength = "0000000000000000000000000000000000000000000000000000000000000000"
  
  -- rs array with 3 elements
  let rsLength = "0000000000000000000000000000000000000000000000000000000000000003"
  let r1 = "8c75b34415f03167d2c0dc6b7541c70943bc15eb5b69ce0daa4a6bcd52ce87a5"
  let r2 = "a6919524b2c7e5d09c5008ec768f9dc61dc67dce99d2bd1a2c64ee72e8e4e951"
  let r3 = "4fbe5ff8ac79dff8d19815cc5eb610c5bc6a2493ae45da97250f504680e18955"
  
  -- ss array with 2 elements (MISMATCH!)
  let ssLength = "0000000000000000000000000000000000000000000000000000000000000002"
  let s1 = "36e4960d5792282d0e0df140c75ae225bf24e45b02fd7570a65a80bd2757f563"
  let s2 = "07e48c64d284775de3f4ef733a57db0abc9848f794f25fc4031feca4bc0dda56"
  
  let mismatchedPayload = reportContext <> reportDataOffset <> rsOffset <> ssOffset <> rawVs <> reportDataLength <> rsLength <> r1 <> r2 <> r3 <> ssLength <> s1 <> s2
  
  testRunner <- alice `submit` createCmd ReportTestRunner with party = alice
  
  -- This should fail because rs and ss have different lengths
  submitMustFail alice do
    exerciseCmd testRunner TestParseSignedReport with payload = mismatchedPayload

-- Test: Parsing with empty rs/ss arrays
testParseSignedReportEmptySignatures : Script ()
testParseSignedReportEmptySignatures = do
  alice <- allocateParty "Alice"
  
  -- Create payload with empty signature arrays
  let reportContext = "0006bd87830d5f336e205cf5c63329a1dab8f5d56812eaeb7c69300e66ab8e220000000000000000000000000000000000000000000000000000000017568517"<>"0000000000000000000000000000000000000000000000000000000000000000"
  let reportDataOffset = "00000000000000000000000000000000000000000000000000000000000000e0"  -- 224
  let rsOffset = "0000000000000000000000000000000000000000000000000000000000000120"  -- 288 (224 + 32 reportDataLen + 32 reportData)
  let ssOffset = "0000000000000000000000000000000000000000000000000000000000000140"  -- 320 (288 + 32 rsLen)
  let rawVs = "0000000000000000000000000000000000000000000000000000000000000000"
  
  -- reportData with minimal content (32 bytes)
  let reportDataLength = "0000000000000000000000000000000000000000000000000000000000000020"
  let reportDataContent = "00030ab7d02fbba9c6304f98824524407b1f494741174320cfd17a2c22eec1de"
  
  -- Empty rs array (length = 0)
  let rsLength = "0000000000000000000000000000000000000000000000000000000000000000"
  
  -- Empty ss array (length = 0)
  let ssLength = "0000000000000000000000000000000000000000000000000000000000000000"
  
  let emptySignaturesPayload = reportContext <> reportDataOffset <> rsOffset <> ssOffset <> rawVs <> reportDataLength <> reportDataContent <> rsLength <> ssLength
  
  -- This should parse successfully but will have empty signature arrays
  let signedReport = parseSignedReport emptySignaturesPayload
  
  -- Verify empty signature arrays
  length (rs signedReport) === 0
  length (ss signedReport) === 0
  length (signedReport.reportContext) === 3  -- Access record field directly

-- Test parsing with invalid offset pointing outside payload - should fail
testParseSignedReportInvalidOffset : Script ()
testParseSignedReportInvalidOffset = do
  alice <- allocateParty "Alice"
  
  -- Create payload with offset pointing way beyond the actual payload
  let reportContext = "0006bd87830d5f336e205cf5c63329a1dab8f5d56812eaeb7c69300e66ab8e220000000000000000000000000000000000000000000000000000000017568517000000000000000000000000000000000000000000000000000000000000000"
  let reportDataOffset = "0000000000000000000000000000000000000000000000000000000000009999"  -- Invalid offset
  let rsOffset = "0000000000000000000000000000000000000000000000000000000000000220"
  let ssOffset = "0000000000000000000000000000000000000000000000000000000000000260"
  let rawVs = "0101000001010000000000000000000000000000000000000000000000000000"
  
  let invalidOffsetPayload = reportContext <> reportDataOffset <> rsOffset <> ssOffset <> rawVs
  
  testRunner <- alice `submit` createCmd ReportTestRunner with party = alice
  
  -- This should fail due to invalid offset
  submitMustFail alice do
    exerciseCmd testRunner TestParseSignedReport with payload = invalidOffsetPayload

-- Test parsing with maximum number of signatures (boundary test)
testParseSignedReportMaximumSignatures : Script ()
testParseSignedReportMaximumSignatures = do
  -- Create payload with 31 signatures (maximum allowed)
  let reportContext = "0006bd87830d5f336e205cf5c63329a1dab8f5d56812eaeb7c69300e66ab8e220000000000000000000000000000000000000000000000000000000017568517"<>"0000000000000000000000000000000000000000000000000000000000000000"
  let reportDataOffset = "00000000000000000000000000000000000000000000000000000000000000e0"  -- 224
  let rsOffset = "0000000000000000000000000000000000000000000000000000000000000120"  -- 288 (224 + 32 len + 32 data)
  let ssOffset = "0000000000000000000000000000000000000000000000000000000000000520"  -- 1312 (288 + 32 len + 31*32 rs values)
  let rawVs = "0101010101010101010101010101010101010101010101010101010101010100"  -- Padded to 32 bytes (31 values + padding)
  
  -- reportData (minimal)
  let reportDataLength = "0000000000000000000000000000000000000000000000000000000000000020"
  let reportDataContent = "00030ab7d02fbba9c6304f98824524407b1f494741174320cfd17a2c22eec1de"
  
  -- Create 31 rs values (using a simple repeated pattern)
  let rsLength = "000000000000000000000000000000000000000000000000000000000000001f"  -- 31 in hex
  let singleR = "8c75b34415f03167d2c0dc6b7541c70943bc15eb5b69ce0daa4a6bcd52ce87a5"
  let rsArray = rsLength <> (foldl (<>) "" (replicate 31 singleR))
  
  -- Create 31 ss values
  let ssLength = "000000000000000000000000000000000000000000000000000000000000001f"
  let singleS = "36e4960d5792282d0e0df140c75ae225bf24e45b02fd7570a65a80bd2757f563"
  let ssArray = ssLength <> (foldl (<>) "" (replicate 31 singleS))
  
  let maxSigsPayload = reportContext <> reportDataOffset <> rsOffset <> ssOffset <> rawVs <> reportDataLength <> reportDataContent <> rsArray <> ssArray
  
  -- This should parse successfully
  let signedReport = parseSignedReport maxSigsPayload
  
  -- Verify we have 31 signatures
  length (rs signedReport) === 31
  length (ss signedReport) === 31

-- Test parsing with reportContext containing special values
testParseSignedReportSpecialContextValues : Script ()
testParseSignedReportSpecialContextValues = do
  -- Test with all-zeros context
  let reportContextZeros = "0000000000000000000000000000000000000000000000000000000000000000"<>"0000000000000000000000000000000000000000000000000000000000000000"<>"0000000000000000000000000000000000000000000000000000000000000000"
  let reportDataOffset = "00000000000000000000000000000000000000000000000000000000000000e0"  -- 224
  let rsOffset = "0000000000000000000000000000000000000000000000000000000000000120"  -- 288 (224 + 32 len + 32 data)
  let ssOffset = "0000000000000000000000000000000000000000000000000000000000000160"  -- 352 (288 + 32 rsLen + 32 r1)
  let rawVs = "0100000000000000000000000000000000000000000000000000000000000000"
  
  let reportDataLength = "0000000000000000000000000000000000000000000000000000000000000020"
  let reportDataContent = "00030ab7d02fbba9c6304f98824524407b1f494741174320cfd17a2c22eec1de"
  
  let rsLength = "0000000000000000000000000000000000000000000000000000000000000001"
  let r1 = "8c75b34415f03167d2c0dc6b7541c70943bc15eb5b69ce0daa4a6bcd52ce87a5"
  
  let ssLength = "0000000000000000000000000000000000000000000000000000000000000001"
  let s1 = "36e4960d5792282d0e0df140c75ae225bf24e45b02fd7570a65a80bd2757f563"
  
  let specialContextPayload = reportContextZeros <> reportDataOffset <> rsOffset <> ssOffset <> rawVs <> reportDataLength <> reportDataContent <> rsLength <> r1 <> ssLength <> s1
  
  -- This should parse successfully
  let signedReport = parseSignedReport specialContextPayload
  
  -- Verify all-zeros context
  let context = reportContext signedReport
  length context === 3
  head context === "0000000000000000000000000000000000000000000000000000000000000000"
  (context !! 1) === "0000000000000000000000000000000000000000000000000000000000000000"
  (context !! 2) === "0000000000000000000000000000000000000000000000000000000000000000"

-- Test parsing at boundary (exactly minSignedReportSize with valid structure)
testParseSignedReportMinimumSize : Script ()
testParseSignedReportMinimumSize = do
  alice <- allocateParty "Alice"
  
  -- Create a minimal valid payload that meets the minimum size requirement
  -- This payload has empty reportData and empty signatures, which is valid structure
  let reportContext = "0006bd87830d5f336e205cf5c63329a1dab8f5d56812eaeb7c69300e66ab8e220000000000000000000000000000000000000000000000000000000017568517"<>"0000000000000000000000000000000000000000000000000000000000000000"
  let reportDataOffset = "00000000000000000000000000000000000000000000000000000000000000e0"
  let rsOffset = "0000000000000000000000000000000000000000000000000000000000000100"
  let ssOffset = "0000000000000000000000000000000000000000000000000000000000000120"
  let rawVs = "0000000000000000000000000000000000000000000000000000000000000000"
  
  -- Empty reportData (just length = 0)
  let reportDataLength = "0000000000000000000000000000000000000000000000000000000000000000"
  
  -- Empty rs array
  let rsLength = "0000000000000000000000000000000000000000000000000000000000000000"
  
  -- Empty ss array
  let ssLength = "0000000000000000000000000000000000000000000000000000000000000000"
  
  -- This is 10 * 32-byte words = 320 bytes
  let minSizePayload = reportContext <> reportDataOffset <> rsOffset <> ssOffset <> rawVs <> reportDataLength <> rsLength <> ssLength
  
  -- Verify the payload is valid hex and has expected byte count
  byteCount minSizePayload === 320
  
  -- Parse and verify it has empty arrays
  let signedReport = parseSignedReport minSizePayload
  length (rs signedReport) === 0
  length (ss signedReport) === 0
