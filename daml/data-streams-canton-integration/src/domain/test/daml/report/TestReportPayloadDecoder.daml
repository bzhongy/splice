module TestReportPayloadDecoder where

import Daml.Script
import DA.Assert ((===))
import DA.Crypto.Text (BytesHex, byteCount)
import ReportPayloadDecoder

-- Helper template to test pure functions that use `error` via submitMustFail
template TestRunner
  with
    owner : Party
  where
    signatory owner

    choice TestReadU256AsU63 : Int
      with
        bytes : BytesHex
      controller owner
      do
        return (readU256AsU63 bytes)

    choice TestReadBytes : BytesHex
      with
        payload : BytesHex
        offset : Int
      controller owner
      do
        return (readBytes payload offset)

    choice TestReadBytes32Array : [BytesHex]
      with
        payload : BytesHex
        offset : Int
      controller owner
      do
        return (readBytes32Array payload offset)

-- Test: readU256AsU63 with too short input - should fail
testReadU256AsU63TooShort : Script ()
testReadU256AsU63TooShort = do
  alice <- allocateParty "alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice
  let shortBytes = "00000000000000000000000000000000"

  submitMustFail alice $ exerciseCmd testRunner TestReadU256AsU63 with bytes = shortBytes

-- Test readU256AsU63 with too long input - should fail
testReadU256AsU63TooLong : Script ()
testReadU256AsU63TooLong = do
  alice <- allocateParty "alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice
  let longBytes = "0000000000000000000000000000000000000000000000000000000000000000000000000000"

  submitMustFail alice $ exerciseCmd testRunner TestReadU256AsU63 with bytes = longBytes

-- Test readU256AsU63 with valid input - should return correct values
testReadU256AsU63Valid : Script ()
testReadU256AsU63Valid = do
  -- Test case 1: All zeros should return 0
  let allZeros = "0000000000000000000000000000000000000000000000000000000000000000"
  let result1 = readU256AsU63 allZeros
  result1 === 0

  -- Test case 2: 512
  let bytes512 = "0000000000000000000000000000000000000000000000000000000000000200"
  let result2 = readU256AsU63 bytes512
  result2 === 512

  -- Test case 3: 224
  let bytes224 = "00000000000000000000000000000000000000000000000000000000000000e0"
  let result3 = readU256AsU63 bytes224
  result3 === 224

  -- Test case 4: 57344
  let bytes57344 = "000000000000000000000000000000000000000000000000000000000000e000"
  let result4 = readU256AsU63 bytes57344
  result4 === 57344

  -- Test case 5: Max U63 (2^63-1) should work
  let maxU63 = "0000000000000000000000000000000000000000000000007fffffffffffffff"
  let result5 = readU256AsU63 maxU63
  result5 === 9223372036854775807

-- Test: U63 max + 1 (2^63) should fail
testReadU256AsU63MaxPlusOne : Script ()
testReadU256AsU63MaxPlusOne = do
  alice <- allocateParty "alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice
  let overflow = "0000000000000000000000000000000000000000000000008000000000000000"
  submitMustFail alice $ exerciseCmd testRunner TestReadU256AsU63 with bytes = overflow

-- Test: fromHex doesn't support negatives - bit 63 set fails even with upper bits 0
testReadU256AsU63NoNegativeSupport : Script ()
testReadU256AsU63NoNegativeSupport = do
  alice <- allocateParty "alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice
  let wouldBeNegativeOne = "000000000000000000000000000000000000000000000000ffffffffffffffff"
  submitMustFail alice $ exerciseCmd testRunner TestReadU256AsU63 with bytes = wouldBeNegativeOne

-- Test: readBytes with insufficient length - should fail
testReadBytesInsufficientLength : Script ()
testReadBytesInsufficientLength = do
  alice <- allocateParty "alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice
  let shortPayload = "00000000000000000000000000000000"
  let offset = 8

  submitMustFail alice $ exerciseCmd testRunner TestReadBytes with payload = shortPayload, offset = offset

-- Test readBytes with overflow - should fail
testReadBytesOverflow : Script ()
testReadBytesOverflow = do
  alice <- allocateParty "alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice
  let lengthField = "0000000000000000000000000000000000000000000000000000000000000064"
  let someData = "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20"
  let overflowPayload = lengthField <> someData
  let offset = 0

  submitMustFail alice $ exerciseCmd testRunner TestReadBytes with payload = overflowPayload, offset = offset

-- Test readBytes with valid input - should work correctly
testReadBytesValid : Script ()
testReadBytesValid = do
  -- Test case 1: Read 4 bytes of data
  let fourBytesLengthField = "0000000000000000000000000000000000000000000000000000000000000004"
  let fourBytesData = "0a141e28"
  let fourBytesPadding = "0000000000000000000000000000000000000000000000000000"
  let fourBytesPayload = fourBytesLengthField <> fourBytesData <> fourBytesPadding
  let fourBytesResult = readBytes fourBytesPayload 0
  fourBytesResult === "0a141e28"

  -- Test case 2: Read 0 bytes (empty array)
  let emptyLengthField = "0000000000000000000000000000000000000000000000000000000000000000"
  let emptyPadding = "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20"
  let emptyPayload = emptyLengthField <> emptyPadding
  let emptyResult = readBytes emptyPayload 0
  byteCount emptyResult === 0

  -- Test case 3: Read from non-zero offset
  let offsetPrefix = "636261605f5e5d5c5b5a595857565554535251504f4e4d4c4b4a494847464544"
  let offsetLengthField = "0000000000000000000000000000000000000000000000000000000000000003"
  let offsetData = "646566"
  let offsetPayload = offsetPrefix <> offsetLengthField <> offsetData
  let offsetResult = readBytes offsetPayload 32
  offsetResult === "646566"

-- Test: readBytes32Array with payload length not divisible by 32 - should fail
testReadBytesAlignment : Script ()
testReadBytesAlignment = do
  alice <- allocateParty "alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice
  let lengthField = "0000000000000000000000000000000000000000000000000000000000000001"
  let dataBytes = "2a"
  let misalignedPayload = lengthField <> dataBytes

  submitMustFail alice $ exerciseCmd testRunner TestReadBytes32Array with payload = misalignedPayload, offset = 0

-- Test: readBytes32Array off-by-one validation (160 bytes = 5 words, max 4 elements)
testReadBytes32ArrayOffByOne : Script ()
testReadBytes32ArrayOffByOne = do
  alice <- allocateParty "alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice
  
  -- 160-byte payload: length word + 4 data words = 5 words total
  let word1 = "1111111111111111111111111111111111111111111111111111111111111111"
  let word2 = "2222222222222222222222222222222222222222222222222222222222222222"
  let word3 = "3333333333333333333333333333333333333333333333333333333333333333"
  let word4 = "4444444444444444444444444444444444444444444444444444444444444444"

  -- length=4 should succeed (exact fit)
  let length4 = "0000000000000000000000000000000000000000000000000000000000000004"
  let payload4 = length4 <> word1 <> word2 <> word3 <> word4
  result <- submit alice $ exerciseCmd testRunner TestReadBytes32Array with payload = payload4, offset = 0
  length result === 4

  -- length=5 should fail (off-by-one: max is 4)
  let length5 = "0000000000000000000000000000000000000000000000000000000000000005"
  let payload5 = length5 <> word1 <> word2 <> word3 <> word4
  submitMustFail alice $ exerciseCmd testRunner TestReadBytes32Array with payload = payload5, offset = 0
