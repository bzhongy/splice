module ReportPayloadDecoder where

import DA.Crypto.Text (BytesHex, sliceHexBytes, byteCount, HasFromHex(..))
import DA.Optional (fromSomeNote)

-- EVM word size in bytes (32 bytes = 256 bits)
wordSize : Int
wordSize = 32

-- Converts 256-bit value to unsigned 63-bit integer (max 2^63-1) as fromHex does not perform sign extension, only accepts positive values
readU256AsU63 : BytesHex -> Int
readU256AsU63 slice =
  let sliceBytes = byteCount slice
  in
    if sliceBytes /= wordSize
      then error ("Invalid slice length when reading u256 as u63: " <> show sliceBytes <> ". Expected " <> show wordSize)
      else fromSomeNote "Failed to convert hex to int" (fromHex slice)

-- Reads a dynamic bytes array from the payload at the specified offset
readBytes : BytesHex -> Int -> BytesHex
readBytes payload offset =
  let 
    dataLength = byteCount payload
    _ = if offset + wordSize > dataLength
        then error ("Malformed payload: offset " <> show offset <> " + word size " <> show wordSize <> " exceeds data length " <> show dataLength)
        else ()
    
    -- Read length from first word at offset
    lengthSlice = case sliceHexBytes payload (offset + 1) (offset + wordSize + 1) of
                    Left err -> error err
                    Right slice -> slice
    len = readU256AsU63 lengthSlice
    
    -- Validate data bounds
    dataStart = offset + wordSize
    _ = if dataStart > dataLength || len > dataLength - dataStart
        then error ("Invalid length " <> show len <> " at offset " <> show dataStart)
        else ()
    
    -- Extract bytes
    result = case sliceHexBytes payload (dataStart + 1) (dataStart + len + 1) of
               Left err -> error err
               Right bytes -> bytes
  in
    result

-- Reads a dynamic array of 32-byte words from the payload at the specified offset
readBytes32Array : BytesHex -> Int -> [BytesHex]
readBytes32Array payload offset =
  let 
    dataLength = byteCount payload
    _ = if offset + wordSize > dataLength
        then error ("Offset out of bounds: " <> show offset <> " + " <> show wordSize <> " > " <> show dataLength)
        else ()
    
    -- Read and validate array length
    lengthSlice = case sliceHexBytes payload (offset + 1) (offset + wordSize + 1) of
                    Left err -> error err
                    Right slice -> slice
                    
    len = readU256AsU63 lengthSlice
    -- Calculate the number of byte32 arrays
    maxElements = (dataLength - offset - wordSize) / wordSize
    _ = if len < 0 || len > maxElements
        then error ("Invalid array length: " <> show len <> " (max: " <> show maxElements <> ")")
        else ()
    
    -- Calculate bounds
    dataStart = offset + wordSize
    totalSize = len * wordSize
    _ = if dataStart > dataLength || totalSize > dataLength - dataStart
        then error ("Array bounds check failed: start=" <> show dataStart <> ", totalSize=" <> show totalSize <> ", dataLength=" <> show dataLength)
        else ()
    
    -- Extract array data
    arraySlice = case sliceHexBytes payload (dataStart + 1) (dataStart + totalSize + 1) of
                   Left err -> error err
                   Right slice -> slice
  in
    extractWords arraySlice 0 len

-- Extracts a single 32-byte word from the payload at the specified word index
extractWord : BytesHex -> Int -> BytesHex
extractWord payload wordIndex =
  let offset = wordIndex * wordSize
      dataLength = byteCount payload
  in
    if offset + wordSize > dataLength
      then error ("Extract word out of bounds: word " <> show wordIndex <> " at offset " <> show offset <> " exceeds length " <> show dataLength)
      else
        case sliceHexBytes payload (offset + 1) (offset + wordSize + 1) of
          Left err -> error err
          Right result -> result

-- Recursively extracts multiple 32-byte words from a byte array
extractWords : BytesHex -> Int -> Int -> [BytesHex]
extractWords payload index len
  | index >= len = []
  | otherwise =
      let word = extractWord payload index
      in word :: extractWords payload (index + 1) len
