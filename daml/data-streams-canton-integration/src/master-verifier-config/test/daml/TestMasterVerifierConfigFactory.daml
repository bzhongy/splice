module TestMasterVerifierConfigFactory where

import MasterVerifierConfigFactory
import VerifierConfig
import Types.VerifierConfigState
import Interface.ManagedContractFactory
import Interface.ManagedContract
import Interface.ConfirmedOwner
import Interface.Observable
import qualified Interface.TypeAndVersion
import qualified DA.Map as Map
import qualified DA.Set as Set
import Daml.Script
import DA.Assert ((===))
import DA.Crypto.Text (BytesHex)

-- Helper to query VerifierConfig by UUID
queryVerifierConfigByUuid : Party -> Text -> Script (ContractId VerifierConfig)
queryVerifierConfigByUuid party uuid = do
  configs <- query @VerifierConfig party
  let [(cid, _)] = filter (\(_, c) -> c.managedContractView.uuid == uuid) configs
  return cid

testConfigDigest : BytesHex
testConfigDigest = "0006f9b553e393ced311551efd30d1decedb63d76ad41737462e2cdbbdff1578"

invalidShortConfigDigest : BytesHex
invalidShortConfigDigest = "abcd"

testPublicKey1 : BytesHex
testPublicKey1 = "0411111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

testPublicKey2 : BytesHex
testPublicKey2 = "0422222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222"

testPublicKey3 : BytesHex
testPublicKey3 = "0433333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333"

testPublicKey4 : BytesHex
testPublicKey4 = "0444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444"

testPublicKey5 : BytesHex
testPublicKey5 = "0455555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555"

testPublicKey6 : BytesHex
testPublicKey6 = "0466666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666"

testPublicKey7 : BytesHex
testPublicKey7 = "0477777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777"

testPublicKey8 : BytesHex
testPublicKey8 = "0488888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888"

testPublicKey9 : BytesHex
testPublicKey9 = "0499999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"

testPublicKeyA : BytesHex
testPublicKeyA = "04aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

testPublicKeyB : BytesHex
testPublicKeyB = "04bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"

invalidShortPublicKey : BytesHex
invalidShortPublicKey = "22222222"

-- Test helper: Create a MasterVerifierConfigFactory with empty state
createTestFactory : Party -> Script (ContractId MasterVerifierConfigFactory)
createTestFactory owner = do
  submit owner $ createCmd MasterVerifierConfigFactory with
    confirmedOwnerView = ConfirmedOwnerView with
      owner = owner
      pendingOwner = None
    observableView = ObservableView with
      observers = []
    managedContractFactoryView = ManagedContractFactoryView with
      contracts = Set.empty
    verifierConfigStateView = VerifierConfigStateView with
      verifierStates = Map.empty

-- Test: Add observer to factory
testAddObserver : Script ()
testAddObserver = script do
  owner <- allocateParty "Owner"
  observer <- allocateParty "Observer"
  factoryCid <- createTestFactory owner

  observableCid <- submit owner $ exerciseCmd (toInterfaceContractId @Observable factoryCid) AddObserver with
    newObserver = observer

  Some factory <- queryContractId owner (fromInterfaceContractId @MasterVerifierConfigFactory observableCid)
  factory.observableView.observers === [observer]

-- Test: Remove observer from factory
testRemoveObserver : Script ()
testRemoveObserver = script do
  owner <- allocateParty "Owner"
  observer <- allocateParty "Observer"
  factoryCid <- createTestFactory owner

  observableCid <- submit owner $ exerciseCmd (toInterfaceContractId @Observable factoryCid) AddObserver with
    newObserver = observer

  observableCid2 <- submit owner $ exerciseCmd observableCid RemoveObserver with
    observerToRemove = observer

  Some factory <- queryContractId owner (fromInterfaceContractId @MasterVerifierConfigFactory observableCid2)
  factory.observableView.observers === []

-- Test: Transfer and accept ownership
testTransferOwnershipAndAccept : Script ()
testTransferOwnershipAndAccept = script do
  owner <- allocateParty "Owner"
  newOwner <- allocateParty "NewOwner"
  factoryCid <- createTestFactory owner

  observableCid <- submit owner $ exerciseCmd (toInterfaceContractId @Observable factoryCid) AddObserver with
    newObserver = newOwner

  let factoryCidWithObserver = fromInterfaceContractId @MasterVerifierConfigFactory observableCid

  confirmedOwnerCid <- submit owner $ exerciseCmd (toInterfaceContractId @ConfirmedOwner factoryCidWithObserver) TransferOwnership with
    newOwner = newOwner

  Some factory1 <- queryContractId owner (fromInterfaceContractId @MasterVerifierConfigFactory confirmedOwnerCid)
  factory1.confirmedOwnerView.pendingOwner === Some newOwner

  confirmedOwnerCid2 <- submit newOwner $ exerciseCmd confirmedOwnerCid AcceptOwnership

  Some factory2 <- queryContractId newOwner (fromInterfaceContractId @MasterVerifierConfigFactory confirmedOwnerCid2)
  factory2.confirmedOwnerView.owner === newOwner
  factory2.confirmedOwnerView.pendingOwner === None

-- Test: NewContract creates contract with correct owner, pendingOwner, observers and signatories
testNewContract : Script ()
testNewContract = script do
  owner <- allocateParty "Owner"
  user <- allocateParty "User"

  -- Create factory with config
  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  -- Deploy VerifierConfig for user
  factoryCid2Interface <- submit owner $ exerciseCmd (toInterfaceContractId @ManagedContractFactory factoryCid1) NewContract with
    users = [user]

  let factoryCid2 = fromInterfaceContractId @MasterVerifierConfigFactory factoryCid2Interface

  -- Query the factory and created VerifierConfig
  Some factory <- queryContractId owner factoryCid2
  userConfigCid <- queryVerifierConfigByUuid owner (show user)
  Some userConfig <- queryContractId user userConfigCid

  -- Test owner is set to factory owner
  userConfig.confirmedOwnerView.owner === owner

  -- Test pendingOwner is None
  userConfig.confirmedOwnerView.pendingOwner === None

  -- Test observers contains the user
  userConfig.observableView.observers === [user]

  -- Test signatories
  -- Verify owner can exercise choices (implicit signatory test)
  Some _ <- queryContractId owner userConfigCid

  -- Test verifierConfigStateView is copied from factory
  userConfig.verifierConfigStateView === factory.verifierConfigStateView
  Map.size userConfig.verifierConfigStateView.verifierStates === 1

  -- Verify config details match factory
  case Map.lookup configDigest userConfig.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found in user contract"
    Some state -> do
      state.f === f
      state.isActive === True
      Map.size state.oracles === 4

-- Test: RemoveContract removes user's contract correctly
testRemoveContract : Script ()
testRemoveContract = script do
  owner <- allocateParty "Owner"
  user1 <- allocateParty "User1"
  user2 <- allocateParty "User2"

  factoryCid <- createTestFactory owner

  -- Deploy VerifierConfig for both users
  factoryCid1Interface <- submit owner $ exerciseCmd (toInterfaceContractId @ManagedContractFactory factoryCid) NewContract with
    users = [user1, user2]

  let factoryCid1 = fromInterfaceContractId @MasterVerifierConfigFactory factoryCid1Interface

  -- Verify both users have contracts (query UUIDs from factory)
  Some factory1 <- queryContractId owner factoryCid1
  Set.size factory1.managedContractFactoryView.contracts === 2
  
  -- Query contracts from ledger
  user1ConfigCid <- queryVerifierConfigByUuid owner (show user1)
  user2ConfigCid <- queryVerifierConfigByUuid owner (show user2)

  -- Verify contracts exist
  Some _ <- queryContractId user1 user1ConfigCid
  Some _ <- queryContractId user2 user2ConfigCid

  -- Remove user1's contract
  factoryCid2Interface <- submit owner $ exerciseCmd (toInterfaceContractId @ManagedContractFactory factoryCid1) RemoveContract with
    contractIds = [toInterfaceContractId @ManagedContract user1ConfigCid]

  let factoryCid2 = fromInterfaceContractId @MasterVerifierConfigFactory factoryCid2Interface

  -- Verify user1's contract is removed from factory
  Some factory2 <- queryContractId owner factoryCid2
  Set.size factory2.managedContractFactoryView.contracts === 1
  Set.member (show user1) factory2.managedContractFactoryView.contracts === False
  Set.member (show user2) factory2.managedContractFactoryView.contracts === True

  -- Verify user1's contract is archived
  None <- queryContractId user1 user1ConfigCid

  -- Verify user2's contract still exists
  Some _ <- queryContractId user2 user2ConfigCid
  return ()

-- Test: UpdateView propagates changes to managed contracts
testUpdateView : Script ()
testUpdateView = script do
  owner <- allocateParty "Owner"
  user1 <- allocateParty "User1"

  factoryCid <- createTestFactory owner

  -- Deploy VerifierConfig for user1
  factoryCid1Interface <- submit owner $ exerciseCmd (toInterfaceContractId @ManagedContractFactory factoryCid) NewContract with
    users = [user1]

  let factoryCid1 = fromInterfaceContractId @MasterVerifierConfigFactory factoryCid1Interface

  -- Verify deployed contract has factory owner and user1 as observer with no config
  user1ConfigCid <- queryVerifierConfigByUuid owner (show user1)

  Some user1Config1 <- queryContractId user1 user1ConfigCid
  user1Config1.confirmedOwnerView.owner === owner
  user1Config1.observableView.observers === [user1]
  Map.size user1Config1.verifierConfigStateView.verifierStates === 0

  -- Set config on factory
  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  factoryCid2 <- submit owner $ exerciseCmd factoryCid1 SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  -- Verify factory has config
  Some factory2 <- queryContractId owner factoryCid2
  Map.size factory2.verifierConfigStateView.verifierStates === 1

  -- UpdateContract to push config to deployed contracts
  factoryCid3Interface <- submit owner $ exerciseCmd (toInterfaceContractId @ManagedContractFactory factoryCid2) UpdateContract with
    contractIds = [toInterfaceContractId @ManagedContract user1ConfigCid]

  let factoryCid3 = fromInterfaceContractId @MasterVerifierConfigFactory factoryCid3Interface

  -- Verify updated contract has new config but owner and user unchanged
  user1ConfigCid2 <- queryVerifierConfigByUuid owner (show user1)

  Some user1Config2 <- queryContractId user1 user1ConfigCid2
  user1Config2.confirmedOwnerView.owner === owner
  user1Config2.observableView.observers === [user1]
  Map.size user1Config2.verifierConfigStateView.verifierStates === 1

  -- Verify config details match expectations
  case Map.lookup configDigest user1Config2.verifierConfigStateView.verifierStates of
    None -> abort "Config not found"
    Some (state : VerifierConfigDigest) -> do
      state.f === f
      state.isActive === True
      Map.size state.oracles === 4

-- Test: TypeAndVersion returns correct type and version
testTypeAndVersion : Script ()
testTypeAndVersion = script do
  owner <- allocateParty "Owner"
  factoryCid <- createTestFactory owner

  -- Exercise GetTypeAndVersion choice via interface
  typeAndVersion <- submit owner $ exerciseCmd (toInterfaceContractId @Interface.TypeAndVersion.TypeAndVersion factoryCid) Interface.TypeAndVersion.GetTypeAndVersion with
    viewer = owner

  -- Verify type and version
  typeAndVersion === "MasterVerifierConfigFactory:1.0.0"

-- Test: SetViewConfig success path
testSetViewConfig : Script ()
testSetViewConfig = script do
  owner <- allocateParty "Owner"
  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  newFactoryCid <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  Some factory <- queryContractId owner newFactoryCid
  case Map.lookup configDigest factory.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> do
      state.f === f
      state.isActive === True
      Map.size state.oracles === 4

-- Test: SetViewConfig fails with non-owner
testSetConfigFailsWithNonOwner : Script ()
testSetConfigFailsWithNonOwner = script do
  owner <- allocateParty "Owner"
  nonOwner <- allocateParty "NonOwner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Attempt to set config as non-owner (should fail)
  submitMustFail nonOwner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

-- Test: SetViewConfig fails with too many signers
testSetConfigFailsWithTooManySigners : Script ()
testSetConfigFailsWithTooManySigners = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  -- Create 32 signers (max is 31)
  let signers = [show i <> "000000000000000000000000000000000000000" | i <- [1..32]]
  let f = 10

  -- Attempt to set config with too many signers (should fail)
  submitMustFail owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

-- Test: SetViewConfig fails with too few signers
testSetConfigFailsWithTooFewSigners : Script ()
testSetConfigFailsWithTooFewSigners = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3]
  let f = 1  -- Requires > 3*f signers, so 3 <= 3*1 will fail

  -- Attempt to set config with too few signers (should fail)
  submitMustFail owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

-- Test: SetViewConfig fails with fault tolerance zero
testSetConfigFailsWithFaultToleranceZero : Script ()
testSetConfigFailsWithFaultToleranceZero = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2]
  let f = 0

  -- Attempt to set config with f=0 (should fail)
  submitMustFail owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

-- Test: SetViewConfig fails with fault tolerance negative
testSetConfigFailsWithFaultToleranceNegative : Script ()
testSetConfigFailsWithFaultToleranceNegative = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2]
  let f = -1

  -- Attempt to set config with f<0 (should fail)
  submitMustFail owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

-- Test: SetViewConfig fails with duplicate signers
testSetConfigFailsWithDuplicateSigners : Script ()
testSetConfigFailsWithDuplicateSigners = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey1, testPublicKey3]
  let f = 1

  -- Attempt to set config with duplicate signers (should fail)
  submitMustFail owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

-- Test: SetViewConfig fails with empty signers list
testSetConfigFailsWithEmptySignersList : Script ()
testSetConfigFailsWithEmptySignersList = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = []
  let f = 1

  -- Attempt to set config with empty signers (should fail)
  submitMustFail owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

-- Test: SetViewConfig fails with list containing an empty string signer
testSetConfigFailsWithListContainingAnEmptyStringSigner : Script ()
testSetConfigFailsWithListContainingAnEmptyStringSigner = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, "", testPublicKey2, testPublicKey3]
  let f = 1

  -- Attempt to set config with empty string signer (should fail)
  submitMustFail owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

-- Test: SetViewConfig fails with invalid address (wrong length)
testSetConfigFailsWithInvalidAddressLength : Script ()
testSetConfigFailsWithInvalidAddressLength = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, invalidShortPublicKey, testPublicKey3, testPublicKey4]
  let f = 1

  -- Attempt to set config with wrong length address (should fail)
  submitMustFail owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

-- Test: SetViewConfig fails with public key missing 0x04 prefix
testSetConfigFailsWithMissingUncompressedPrefix : Script ()
testSetConfigFailsWithMissingUncompressedPrefix = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  -- Key with correct length but no 0x04 prefix (starts with 00 instead)
  let invalidKeyNoPrefix = "0011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
  let signers = [testPublicKey1, invalidKeyNoPrefix, testPublicKey3, testPublicKey4]
  let f = 1

  -- Attempt to set config with key missing 0x04 prefix (should fail)
  submitMustFail owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

-- Test: SetViewConfig replaces existing config
testSetConfigReplacesExistingConfig : Script ()
testSetConfigReplacesExistingConfig = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let oldSigners = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let oldF = 1

  -- Set initial config
  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = oldSigners
    f = oldF

  -- Verify initial config
  Some factory1 <- queryContractId owner factoryCid1
  case Map.lookup configDigest factory1.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found after initial set"
    Some state1 -> do
      state1.f === oldF
      Map.size state1.oracles === 4

  let newSigners = [testPublicKey5, testPublicKey6, testPublicKey7, testPublicKey8, testPublicKey9, testPublicKeyA, testPublicKeyB]
  let newF = 2

  factoryCid2 <- submit owner $ exerciseCmd factoryCid1 SetViewConfig with
    configDigest = configDigest
    signers = newSigners
    f = newF

  -- Verify config was replaced
  Some factory2 <- queryContractId owner factoryCid2
  case Map.lookup configDigest factory2.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found after replacement"
    Some state2 -> do
      state2.f === newF
      Map.size state2.oracles === 7
      Map.member testPublicKey1 state2.oracles === False
      Map.member testPublicKey5 state2.oracles === True

-- Test: SetViewConfig default is active
testSetConfigDefaultIsActive : Script ()
testSetConfigDefaultIsActive = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Set config
  newFactoryCid <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  -- Verify config is active by default
  Some factory <- queryContractId owner newFactoryCid
  case Map.lookup configDigest factory.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> do
      state.isActive === True

-- Test: SetViewConfig fails with invalid config digest length
testSetConfigWithInvalidConfigDigestLength : Script ()
testSetConfigWithInvalidConfigDigestLength = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = invalidShortConfigDigest  -- Too short, should be 32 bytes
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Attempt to set config with invalid digest length (should fail)
  submitMustFail owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

-- Test: SetViewConfig with exact boundary 3*f+1 signers
testSetConfigWithExactBoundary3fPlus1 : Script ()
testSetConfigWithExactBoundary3fPlus1 = script do
  owner <- allocateParty "Owner"
  factoryCid <- createTestFactory owner

  -- 3*f + 1 = 3*2 + 1 = 7 signers (exact minimum)
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4, testPublicKey5, testPublicKey6, testPublicKey7]
  let numSigners = length signers

  newFactoryCid <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = testConfigDigest
    signers = signers
    f = 2

  Some factory <- queryContractId owner newFactoryCid
  case Map.lookup testConfigDigest factory.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> do
      state.f === 2
      state.isActive === True
      Map.size state.oracles === numSigners

-- Test: SetViewConfig with minimum fault tolerance f=1
testSetConfigWithMinimumFaultTolerance : Script ()
testSetConfigWithMinimumFaultTolerance = script do
  owner <- allocateParty "Owner"
  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let f = 1  -- Minimum valid f
  -- 3*f + 1 = 3*1 + 1 = 4 signers
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let numSigners = length signers

  newFactoryCid <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  Some factory <- queryContractId owner newFactoryCid
  case Map.lookup configDigest factory.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> do
      state.f === f
      state.isActive === True
      Map.size state.oracles === numSigners

-- Test: SetViewConfig fails with f=11 (exceeds maximum for 31 signers)
testSetConfigWithFOf31Fails : Script ()
testSetConfigWithFOf31Fails = script do
  owner <- allocateParty "Owner"
  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  -- Maximum OCR signers is 31, but f=11 requires > 33 signers (3*11=33)
  -- This should fail with InsufficientSigners
  let f = 11  -- Invalid: requires > 33 signers but only 31 max
  let maxSigners = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4, testPublicKey5,
                    testPublicKey6, testPublicKey7, testPublicKey8, testPublicKey9, testPublicKeyA, testPublicKeyB]

  -- Generate 31 unique signers
  let additionalSigners =
        [ "04cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc"
        , "04dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"
        , "04eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
        , "04ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        , "041010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010"
        , "041111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
        , "041212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212"
        , "041313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313"
        , "041414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414"
        , "041515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515"
        , "041616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616"
        , "041717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717"
        , "041818181818181818181818181818181818181818181818181818181818181818181818181818181818181818181818181818181818181818181818181818181818"
        , "041919191919191919191919191919191919191919191919191919191919191919191919191919191919191919191919191919191919191919191919191919191919"
        , "042020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020"
        , "042121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121"
        , "042222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222"
        , "042323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323"
        , "042424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424"
        , "042525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525252525"
        ]
  let allSigners = maxSigners <> additionalSigners

  -- Attempt to set config with f=11 and 31 signers (should fail)
  submitMustFail owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = allSigners
    f = f

-- Test: Activate config
testActivateConfig : Script ()
testActivateConfig = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Set config (active by default)
  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  -- Deactivate it first
  factoryCid2 <- submit owner $ exerciseCmd factoryCid1 DeactivateViewConfig with
    configDigest = configDigest

  -- Verify it's inactive
  Some factory1 <- queryContractId owner factoryCid2
  case Map.lookup configDigest factory1.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> do
      state.isActive === False

  -- Activate config
  factoryCid3 <- submit owner $ exerciseCmd factoryCid2 ActivateViewConfig with
    configDigest = configDigest

  -- Verify config is now active
  Some factory2 <- queryContractId owner factoryCid3
  case Map.lookup configDigest factory2.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found after activation"
    Some state -> do
      state.isActive === True

-- Test: Activate already-active config (idempotent)
testActivateAlreadyActiveConfig : Script ()
testActivateAlreadyActiveConfig = script do
  owner <- allocateParty "Owner"
  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Set config (active by default)
  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  -- Verify it's active
  Some factory1 <- queryContractId owner factoryCid1
  case Map.lookup configDigest factory1.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> state.isActive === True

  -- Activate already-active config (should succeed - idempotent)
  factoryCid2 <- submit owner $ exerciseCmd factoryCid1 ActivateViewConfig with
    configDigest = configDigest

  -- Verify still active
  Some factory2 <- queryContractId owner factoryCid2
  case Map.lookup configDigest factory2.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found after re-activation"
    Some state -> state.isActive === True

-- Test: Activate config fails as non-admin
testActivateConfigFailsAsNonAdmin : Script ()
testActivateConfigFailsAsNonAdmin = script do
  owner <- allocateParty "Owner"
  nonAdmin <- allocateParty "NonAdmin"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Set config
  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  -- Attempt to activate as non-admin (should fail)
  submitMustFail nonAdmin $ exerciseCmd factoryCid1 ActivateViewConfig with
    configDigest = configDigest

-- Test: Activate invalid config digest fails
testActivateInvalidConfigDigestFails : Script ()
testActivateInvalidConfigDigestFails = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest

  -- Attempt to activate a config that doesn't exist (should fail)
  submitMustFail owner $ exerciseCmd factoryCid ActivateViewConfig with
    configDigest = configDigest

-- Test: Activate with empty digest fails
testActivateConfigWithEmptyDigest : Script ()
testActivateConfigWithEmptyDigest = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Set a valid config first
  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  -- Attempt to activate with empty digest (should fail)
  submitMustFail owner $ exerciseCmd factoryCid1 ActivateViewConfig with
    configDigest = ""

-- Test: Activate config with different prefix format (set without 0x, activate with 0x)
testActivateConfigWithPrefixNormalization : Script ()
testActivateConfigWithPrefixNormalization = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigestWithoutPrefix = "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
  let configDigestWithPrefix = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Set config without 0x prefix
  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigestWithoutPrefix
    signers = signers
    f = f

  -- Deactivate first
  factoryCid2 <- submit owner $ exerciseCmd factoryCid1 DeactivateViewConfig with
    configDigest = configDigestWithoutPrefix

  -- Activate with 0x prefix
  factoryCid3 <- submit owner $ exerciseCmd factoryCid2 ActivateViewConfig with
    configDigest = configDigestWithPrefix

  -- Verify it's active
  Some factory3 <- queryContractId owner factoryCid3
  case Map.lookup configDigestWithoutPrefix factory3.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> do
      state.isActive === True

-- Test: Deactivate config with different prefix format (set with 0x, deactivate without 0x)
testDeactivateConfigWithPrefixNormalization : Script ()
testDeactivateConfigWithPrefixNormalization = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigestWithPrefix = "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"
  let configDigestWithoutPrefix = "fedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Set config with 0x prefix
  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigestWithPrefix
    signers = signers
    f = f

  -- Deactivate without 0x prefix
  factoryCid2 <- submit owner $ exerciseCmd factoryCid1 DeactivateViewConfig with
    configDigest = configDigestWithoutPrefix

  -- Verify it's inactive
  Some factory2 <- queryContractId owner factoryCid2
  case Map.lookup configDigestWithoutPrefix factory2.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> do
      state.isActive === False

-- Test: Deactivate config
testDeactivateConfig : Script ()
testDeactivateConfig = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Set config (active by default)
  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  -- Verify it's active
  Some factory1 <- queryContractId owner factoryCid1
  case Map.lookup configDigest factory1.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> do
      state.isActive === True

  -- Deactivate config
  factoryCid2 <- submit owner $ exerciseCmd factoryCid1 DeactivateViewConfig with
    configDigest = configDigest

  -- Verify config is now inactive
  Some factory2 <- queryContractId owner factoryCid2
  case Map.lookup configDigest factory2.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found after deactivation"
    Some state -> do
      state.isActive === False

-- Test: Deactivate config fails as non-admin
testDeactivateConfigFailsAsNonAdmin : Script ()
testDeactivateConfigFailsAsNonAdmin = script do
  owner <- allocateParty "Owner"
  nonAdmin <- allocateParty "NonAdmin"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Set config
  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  -- Attempt to deactivate as non-admin (should fail)
  submitMustFail nonAdmin $ exerciseCmd factoryCid1 DeactivateViewConfig with
    configDigest = configDigest

-- Test: Deactivate invalid config digest fails
testDeactivateInvalidConfigDigestFails : Script ()
testDeactivateInvalidConfigDigestFails = script do
  owner <- allocateParty "Owner"

  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest

  -- Attempt to deactivate a config that doesn't exist (should fail)
  submitMustFail owner $ exerciseCmd factoryCid DeactivateViewConfig with
    configDigest = configDigest

-- Test: Deactivate already-inactive config (idempotent)
testDeactivateAlreadyInactiveConfig : Script ()
testDeactivateAlreadyInactiveConfig = script do
  owner <- allocateParty "Owner"
  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Set config (active by default)
  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  -- Deactivate config
  factoryCid2 <- submit owner $ exerciseCmd factoryCid1 DeactivateViewConfig with
    configDigest = configDigest

  -- Verify it's inactive
  Some factory2 <- queryContractId owner factoryCid2
  case Map.lookup configDigest factory2.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> state.isActive === False

  -- Deactivate already-inactive config (should succeed - idempotent)
  factoryCid3 <- submit owner $ exerciseCmd factoryCid2 DeactivateViewConfig with
    configDigest = configDigest

  -- Verify still inactive
  Some factory3 <- queryContractId owner factoryCid3
  case Map.lookup configDigest factory3.verifierConfigStateView.verifierStates of
    None -> abort "Config digest not found"
    Some state -> state.isActive === False

-- Test: Full config state lifecycle (Set -> Deactivate -> Activate -> Deactivate)
testConfigStateLifecycle : Script ()
testConfigStateLifecycle = script do
  owner <- allocateParty "Owner"
  factoryCid <- createTestFactory owner

  let configDigest = testConfigDigest
  let signers = [testPublicKey1, testPublicKey2, testPublicKey3, testPublicKey4]
  let f = 1

  -- Step 1: Set config (active by default)
  factoryCid1 <- submit owner $ exerciseCmd factoryCid SetViewConfig with
    configDigest = configDigest
    signers = signers
    f = f

  Some factory1 <- queryContractId owner factoryCid1
  case Map.lookup configDigest factory1.verifierConfigStateView.verifierStates of
    None -> abort "Config not found after set"
    Some state -> do
      state.isActive === True
      state.f === f

  -- Step 2: Deactivate config
  factoryCid2 <- submit owner $ exerciseCmd factoryCid1 DeactivateViewConfig with
    configDigest = configDigest

  Some factory2 <- queryContractId owner factoryCid2
  case Map.lookup configDigest factory2.verifierConfigStateView.verifierStates of
    None -> abort "Config not found after deactivate"
    Some state -> do
      state.isActive === False
      state.f === f  -- f should remain unchanged

  -- Step 3: Activate config
  factoryCid3 <- submit owner $ exerciseCmd factoryCid2 ActivateViewConfig with
    configDigest = configDigest

  Some factory3 <- queryContractId owner factoryCid3
  case Map.lookup configDigest factory3.verifierConfigStateView.verifierStates of
    None -> abort "Config not found after re-activate"
    Some state -> do
      state.isActive === True
      state.f === f

  -- Step 4: Deactivate again
  factoryCid4 <- submit owner $ exerciseCmd factoryCid3 DeactivateViewConfig with
    configDigest = configDigest

  Some factory4 <- queryContractId owner factoryCid4
  case Map.lookup configDigest factory4.verifierConfigStateView.verifierStates of
    None -> abort "Config not found after final deactivate"
    Some state -> do
      state.isActive === False
      state.f === f
