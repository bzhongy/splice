module Util.TestHex where

import Daml.Script
import Util.Hex

-- Helper template to test functions that throw errors
template TestRunner
  with
    owner : Party
  where
    signatory owner
    
    nonconsuming choice TestIntToHex : Text
      with
        n : Int
      controller owner
      do
        return (intToHex n)
    
    nonconsuming choice TestByteToHex : Text
      with
        n : Int
      controller owner
      do
        return (byteToHex n)

-- Test: intToHex converts integers to hexadecimal representation
testIntToHex : Script ()
testIntToHex = script do
  -- Single digit (0-15)
  assertMsg "intToHex 0 should be '0'" (intToHex 0 == "0")
  assertMsg "intToHex 9 should be '9'" (intToHex 9 == "9")
  assertMsg "intToHex 10 should be 'a'" (intToHex 10 == "a")
  assertMsg "intToHex 15 should be 'f'" (intToHex 15 == "f")
  
  -- Two digits (16-255)
  assertMsg "intToHex 16 should be '10'" (intToHex 16 == "10")
  assertMsg "intToHex 255 should be 'ff'" (intToHex 255 == "ff")
  assertMsg "intToHex 100 should be '64'" (intToHex 100 == "64")
  
  -- Three digits (256+)
  assertMsg "intToHex 256 should be '100'" (intToHex 256 == "100")
  assertMsg "intToHex 4095 should be 'fff'" (intToHex 4095 == "fff")
  assertMsg "intToHex 1000 should be '3e8'" (intToHex 1000 == "3e8")

-- Test: intToHex rejects negative numbers
testIntToHexNegative : Script ()
testIntToHexNegative = script do
  alice <- allocateParty "Alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice
  
  -- Should fail with error "intToHex: negative numbers not supported"
  submitMustFail alice $ exerciseCmd testRunner TestIntToHex with n = -1

-- Test: byteToHex converts bytes to 2-character hex strings
testByteToHex : Script ()
testByteToHex = script do
  -- Leading zero padding
  assertMsg "byteToHex 0 should be '00'" (byteToHex 0 == "00")
  assertMsg "byteToHex 1 should be '01'" (byteToHex 1 == "01")
  assertMsg "byteToHex 15 should be '0f'" (byteToHex 15 == "0f")
  
  -- No padding needed
  assertMsg "byteToHex 16 should be '10'" (byteToHex 16 == "10")
  assertMsg "byteToHex 255 should be 'ff'" (byteToHex 255 == "ff")
  assertMsg "byteToHex 128 should be '80'" (byteToHex 128 == "80")

-- Test: byteToHex rejects out-of-range values
testByteToHexOutOfRange : Script ()
testByteToHexOutOfRange = script do
  alice <- allocateParty "Alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice
  
  -- Should fail with error "byteToHex: value must be 0-255"
  submitMustFail alice $ exerciseCmd testRunner TestByteToHex with n = -1
  submitMustFail alice $ exerciseCmd testRunner TestByteToHex with n = 256
  submitMustFail alice $ exerciseCmd testRunner TestByteToHex with n = 1000

-- Test: highBitSet detects high bit in first byte
testHighBitSet : Script ()
testHighBitSet = script do
  -- High bit set (0x80-0xFF)
  assertMsg "0x80 should have high bit set" (highBitSet "80")
  assertMsg "0xff should have high bit set" (highBitSet "ff")
  assertMsg "0xAF should have high bit set" (highBitSet "AF")
  assertMsg "0xc0 should have high bit set" (highBitSet "c0")
  
  -- High bit not set (0x00-0x7F)
  assertMsg "0x7f should not have high bit set" (not (highBitSet "7f"))
  assertMsg "0x00 should not have high bit set" (not (highBitSet "00"))
  assertMsg "0x40 should not have high bit set" (not (highBitSet "40"))
  assertMsg "0x79 should not have high bit set" (not (highBitSet "79"))

-- Test: checkHighBitAtPosition detects high bit at any position
testCheckHighBitAtPosition : Script ()
testCheckHighBitAtPosition = script do
  -- Position 0 (first byte)
  assertMsg "Should detect high bit at position 0" (checkHighBitAtPosition "80" 0)
  assertMsg "Should not detect high bit at position 0" (not (checkHighBitAtPosition "7f" 0))
  
  -- Position 2 (second byte)
  assertMsg "Should detect high bit at position 2" (checkHighBitAtPosition "00ff" 2)
  assertMsg "Should detect high bit at position 2" (checkHighBitAtPosition "00A0" 2)
  assertMsg "Should not detect high bit at position 2" (not (checkHighBitAtPosition "007f" 2))
  
  -- Position 4 (third byte)
  assertMsg "Should detect high bit at position 4" (checkHighBitAtPosition "0000c0" 4)
  assertMsg "Should not detect high bit at position 4" (not (checkHighBitAtPosition "000050" 4))
  
  -- Out of bounds
  assertMsg "Should return False for out of bounds" (not (checkHighBitAtPosition "ff" 4))
  assertMsg "Should return False for empty string" (not (checkHighBitAtPosition "" 0))

-- Test: trimLeadingZeros removes all leading zeros
testTrimLeadingZeros : Script ()
testTrimLeadingZeros = script do
  -- Trim leading zeros
  assertMsg "Should trim leading zeros" (trimLeadingZeros "00001234" == "1234")
  assertMsg "Should trim multiple pairs" (trimLeadingZeros "0000001234" == "1234")
  assertMsg "Should trim to single byte" (trimLeadingZeros "0012" == "12")
  
  -- Preserve at least one byte (minimum "00")
  assertMsg "Should keep at least one byte" (trimLeadingZeros "0000" == "00")
  assertMsg "Should keep single zero" (trimLeadingZeros "00" == "00")
  assertMsg "Should handle empty string" (trimLeadingZeros "" == "00")
  
  -- Trim ALL leading zeros regardless of next byte value
  assertMsg "Should trim even if second byte >= 0x80" (trimLeadingZeros "0080" == "80")
  assertMsg "Should trim if second byte is 0xff" (trimLeadingZeros "00ff" == "ff")
  assertMsg "Should trim if second byte is 0xc0" (trimLeadingZeros "00c0" == "c0")
  assertMsg "Should trim if second byte < 0x80" (trimLeadingZeros "007f" == "7f")
  
  -- Multiple leading zeros
  assertMsg "Should trim multiple leading zeros before high byte" (trimLeadingZeros "000000ff" == "ff")
  assertMsg "Should trim multiple leading zeros before low byte" (trimLeadingZeros "00000012" == "12")

-- Test: stripHexPrefix removes "0x" prefix
testStripHexPrefix : Script ()
testStripHexPrefix = script do
  -- With prefix
  assertMsg "Should strip '0x' prefix" (stripHexPrefix "0x1234" == "1234")
  assertMsg "Should strip '0x' from full address" (stripHexPrefix "0xabcdef" == "abcdef")
  assertMsg "Should strip '0x' from single byte" (stripHexPrefix "0x00" == "00")
  
  -- Without prefix
  assertMsg "Should leave string without prefix unchanged" (stripHexPrefix "1234" == "1234")
  assertMsg "Should leave empty string unchanged" (stripHexPrefix "" == "")
  assertMsg "Should leave single char unchanged" (stripHexPrefix "a" == "a")
  
  -- Edge cases
  assertMsg "Should handle exactly '0x'" (stripHexPrefix "0x" == "")
  assertMsg "Should not strip partial prefix '0'" (stripHexPrefix "0" == "0")
  assertMsg "Should not strip 'x' alone" (stripHexPrefix "x1234" == "x1234")
