module Crypto.TestDerEncoding where

import Daml.Script
import DA.Crypto.Text (BytesHex, PublicKeyHex, byteCount, keccak256, secp256k1WithEcdsaOnly)
import DA.Text qualified as Text
import Crypto.DerEncoding

-- Helper template to test pure functions that use `error` via submitMustFail
template TestRunner
  with
    owner : Party
  where
    signatory owner
    nonconsuming choice TestRawToDerSignature : BytesHex
      with
        r : BytesHex
        s : BytesHex
      controller owner
      do
        return (rawToDerSignature r s)

    nonconsuming choice TestSecp256k1PublicKeyToDer : BytesHex
      with
        publicKey : BytesHex
      controller owner
      do
        return (secp256k1PublicKeyToDer publicKey)

-- Message prefix from test fixtures
messagePrefix : BytesHex
messagePrefix = "19457468657265756d205369676e6564204d6573736167653a0a3332"

-- Apply message prefix and keccak256 hash (as done in Ethereum message signing)
computeSignedHash : BytesHex -> BytesHex
computeSignedHash messageHash =
  keccak256 (messagePrefix <> messageHash)

-- Test data: Message hash
testMessageHash : BytesHex
testMessageHash = "2331173930a149a27cdfb7f96853664ace56a4deeb60c8bf1f8c59765484d522"

-- Test case 1: Signature with R requiring padding (high bit set)
testPublicKey1 : PublicKeyHex
testPublicKey1 = "04ef5483bf20b59c3972cd17b4f232c41a608c06a6dd0a4beb4e1f35ed1d49100cddf07e458cf9708acc69f6265af9db01b3f9c9697024a736350695812a4498b8"

testR1 : BytesHex
testR1 = "80c90159b1bfd23d46da54b617daae35da19fdb17ecc8f97d4ea0b27d3150a26"

testS1 : BytesHex
testS1 = "6cab95f068c7093de7f6feca338ba2b8406d5fe124639b385a864cd5ac9d05aa"

expectedDerSignature1 : BytesHex
expectedDerSignature1 = "304502210080c90159b1bfd23d46da54b617daae35da19fdb17ecc8f97d4ea0b27d3150a2602206cab95f068c7093de7f6feca338ba2b8406d5fe124639b385a864cd5ac9d05aa"

expectedDerPublicKey1 : BytesHex
expectedDerPublicKey1 = "3056301006072a8648ce3d020106052b8104000a03420004ef5483bf20b59c3972cd17b4f232c41a608c06a6dd0a4beb4e1f35ed1d49100cddf07e458cf9708acc69f6265af9db01b3f9c9697024a736350695812a4498b8"

-- Test case 2: Signature with neither R nor S requiring padding
testPublicKey2 : PublicKeyHex
testPublicKey2 = "0441b5ed95b0b644b23ee03102759611df72c9acef7e7abb9ebfdcfefe2cbde51e4ca7387831e93121331e0941ad959b41e194b6678a4589a9c2790787627cce60"

testR2 : BytesHex
testR2 = "1dd952e5b91386d39c28d867b825d6b85fe10ee2495fa0d9f6df947c3f495631"

testS2 : BytesHex
testS2 = "0579450d5d28a6de8f22cb6e21792c6f86e637dbd129c7aadf039dbd441b351a"

expectedDerSignature2 : BytesHex
expectedDerSignature2 = "304402201dd952e5b91386d39c28d867b825d6b85fe10ee2495fa0d9f6df947c3f49563102200579450d5d28a6de8f22cb6e21792c6f86e637dbd129c7aadf039dbd441b351a"

-- Test: Verify DER signature encoding format
testDerSignatureFormat : Script ()
testDerSignatureFormat = script do
  let derSignature = rawToDerSignature testR1 testS1

  assertMsg "Signature should start with 0x30 (SEQUENCE tag)"
    (Text.take 2 derSignature == "30")

  assertMsg "DER signature should match expected value"
    (derSignature == expectedDerSignature1)

  assertMsg "DER signature length should be 70-72 bytes"
    (byteCount derSignature >= 70 && byteCount derSignature <= 72)

-- Test: Verify DER public key encoding
testDerPublicKeyEncoding : Script ()
testDerPublicKeyEncoding = script do
  let derPublicKey = secp256k1PublicKeyToDer testPublicKey1

  assertMsg "DER public key should match expected value"
    (derPublicKey == expectedDerPublicKey1)

  assertMsg "DER public key should be 88 bytes (uncompressed)"
    (byteCount derPublicKey == 88)

  assertMsg "DER public key should start with 0x30 (SEQUENCE)"
    (Text.take 2 derPublicKey == "30")

-- Test: Verify signature with secp256k1WithEcdsaOnly
testSignatureVerification : Script ()
testSignatureVerification = script do
  let derSignature = rawToDerSignature testR1 testS1
  let derPublicKey = secp256k1PublicKeyToDer testPublicKey1
  let signedHash = computeSignedHash testMessageHash
  let isValid = secp256k1WithEcdsaOnly derSignature signedHash derPublicKey

  assertMsg "Signature verification should succeed" isValid

-- Test: Verify second signature (different padding case)
testSecondSignatureVerification : Script ()
testSecondSignatureVerification = script do
  let derSignature2 = rawToDerSignature testR2 testS2
  let derPublicKey2 = secp256k1PublicKeyToDer testPublicKey2
  let signedHash = computeSignedHash testMessageHash
  let isValid = secp256k1WithEcdsaOnly derSignature2 signedHash derPublicKey2

  assertMsg "Second signature verification should succeed" isValid

-- Test: DER signature padding cases
testDerSignaturePaddingCases : Script ()
testDerSignaturePaddingCases = script do
  let der1 = rawToDerSignature testR1 testS1
  assertMsg "Case 1 should be 71 bytes" (byteCount der1 == 71)

  let der2 = rawToDerSignature testR2 testS2
  assertMsg "Case 2 should be 70 bytes" (byteCount der2 == 70)
  assertMsg "Case 2 should match expected" (der2 == expectedDerSignature2)

-- Test: Signature component length validation (1-32 bytes for 256-bit ECDSA)
testSignatureLengthValidation : Script ()
testSignatureLengthValidation = script do
  alice <- allocateParty "Alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice
  
  let validS = "0579450d5d28a6de8f22cb6e21792c6f86e637dbd129c7aadf039dbd441b351a" -- 32 bytes

  -- 31 bytes (valid) - succeeds
  let r31 = "01d952e5b91386d39c28d867b825d6b85fe10ee2495fa0d9f6df947c3f4956" -- 31 bytes (62 hex chars)
  der31 <- submit alice $ exerciseCmd testRunner TestRawToDerSignature with r = r31, s = validS
  assertMsg "31-byte component should succeed" (byteCount der31 > 0)

  -- 32 bytes (valid, maximum) - succeeds
  let r32 = "1dd952e5b91386d39c28d867b825d6b85fe10ee2495fa0d9f6df947c3f495631" -- 32 bytes (64 hex chars)
  der32 <- submit alice $ exerciseCmd testRunner TestRawToDerSignature with r = r32, s = validS
  assertMsg "32-byte component should succeed" (byteCount der32 > 0)

  -- 33 bytes (invalid) - fails with error "r component must be 1-32 bytes"
  let r33 = "FF1dd952e5b91386d39c28d867b825d6b85fe10ee2495fa0d9f6df947c3f495631" -- 33 bytes (66 hex chars)
  submitMustFail alice $ exerciseCmd testRunner TestRawToDerSignature with r = r33, s = validS

-- Test: Public key length and format validation
testPublicKeyValidation : Script ()
testPublicKeyValidation = script do
  alice <- allocateParty "Alice"
  testRunner <- submit alice $ createCmd TestRunner with owner = alice

  -- Valid 65-byte uncompressed key starting with 0x04 (succeeds)
  let validKey = "04ef5483bf20b59c3972cd17b4f232c41a608c06a6dd0a4beb4e1f35ed1d49100cddf07e458cf9708acc69f6265af9db01b3f9c9697024a736350695812a4498b8"
  derKey <- submit alice $ exerciseCmd testRunner TestSecp256k1PublicKeyToDer with publicKey = validKey
  assertMsg "Valid 65-byte key should succeed" (byteCount derKey > 0)

  -- 64 bytes (too short) - fails
  let key64 = "045483bf20b59c3972cd17b4f232c41a608c06a6dd0a4beb4e1f35ed1d49100cddf07e458cf9708acc69f6265af9db01b3f9c9697024a736350695812a4498b8" -- 64 bytes (128 hex chars)
  submitMustFail alice $ exerciseCmd testRunner TestSecp256k1PublicKeyToDer with publicKey = key64

  -- 66 bytes (too long) - fails
  let key66 = "04ef5483bf20b59c3972cd17b4f232c41a608c06a6dd0a4beb4e1f35ed1d49100cddf07e458cf9708acc69f6265af9db01b3f9c9697024a736350695812a4498b8FF" -- 66 bytes (132 hex chars)
  submitMustFail alice $ exerciseCmd testRunner TestSecp256k1PublicKeyToDer with publicKey = key66

  -- 65 bytes but doesn't start with 0x04 (compressed format 0x02) - fails
  let key65Wrong = "02ef5483bf20b59c3972cd17b4f232c41a608c06a6dd0a4beb4e1f35ed1d49100cddf07e458cf9708acc69f6265af9db01b3f9c9697024a736350695812a4498b8" -- 65 bytes but wrong prefix
  submitMustFail alice $ exerciseCmd testRunner TestSecp256k1PublicKeyToDer with publicKey = key65Wrong