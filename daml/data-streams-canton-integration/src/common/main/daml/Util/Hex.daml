module Util.Hex where

import DA.Crypto.Text (BytesHex)
import DA.Text qualified as Text

-- Convert an integer to hexadecimal text representation
intToHex : Int -> Text
intToHex n
  | n < 0 = error "intToHex: negative numbers not supported"
  | n < 10 = show n
  | n == 10 = "a"
  | n == 11 = "b"
  | n == 12 = "c"
  | n == 13 = "d"
  | n == 14 = "e"
  | n == 15 = "f"
  | otherwise =
      let high = n / 16
          low = n % 16
      in intToHex high <> intToHex low

-- Convert a single byte to a 2-character hex string
byteToHex : Int -> BytesHex
byteToHex n
  | n < 0 || n > 255 = error "byteToHex: value must be 0-255"
  | n < 16 = "0" <> intToHex n
  | otherwise = intToHex n

-- Check if the high bit (sign bit) is set at a specific position in hex string
checkHighBitAtPosition : BytesHex -> Int -> Bool
checkHighBitAtPosition hex offset =
  let firstChar = Text.take 1 (Text.drop offset hex)
  in firstChar `elem` ["8", "9", "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]

-- Check if the high bit (sign bit) is set in the first byte of a hex string
highBitSet : BytesHex -> Bool
highBitSet hex = checkHighBitAtPosition hex 0

-- | Remove leading zeros from a hex string but keep at least one byte
trimLeadingZeros : BytesHex -> BytesHex
trimLeadingZeros hex
  | Text.length hex > 2 && Text.take 2 hex == "00" =
      trimLeadingZeros (Text.drop 2 hex)
  | Text.length hex == 0 = "00"
  | otherwise = hex

-- Strip "0x" prefix from a hex string if present
stripHexPrefix : BytesHex -> BytesHex
stripHexPrefix hex
  | Text.length hex >= 2 && Text.take 2 hex == "0x" = Text.drop 2 hex
  | otherwise = hex
